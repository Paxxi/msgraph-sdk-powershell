// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6306, generator: {generator})
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Collections.Generic;
using System.Management.Automation;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using Microsoft.Graph.PowerShell.Runtime.PowerShell;

namespace Microsoft.Graph.PowerShell.Runtime
{
    using static Extensions;

    /// <summary>Get ipSecurityProfiles from security</summary>
    /// <remarks>
    ///     [OpenAPI] security_GetIpSecurityProfiles=>GET:"/security/ipSecurityProfiles/{ipSecurityProfileid}"
    /// </remarks>
    public abstract class GetCmdletBase<TModel> : PSCmdlet,
        IEventListener
        where TModel : class
    {
        protected const string IdParameterSet = "Id";
        protected const string InputObjectParameterSet = "InputObject";
        protected const string ProxyParameterSet = "Proxy";
        protected const string FilterParameterSet = "Filter";
        protected const string SearchParameterSet = "Search";
        protected const string ListParameterSet = "List";

        /// <summary>
        ///     Default number of items per page.
        /// </summary>
        internal const int DefaultPageSize = 100;

        /// <summary>
        ///     Maximum number of items per page.
        /// </summary>
        internal const int MaxPageSize = 999;

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        protected InvocationInfo InvocationInfo;

        /// <summary>
        ///     The <see cref="System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        protected CancellationTokenSource CancellationTokenSource = new CancellationTokenSource();

        private SwitchParameter _count;

        /// <summary>Backing field for <see cref="Top" /> property.</summary>
        private int _top = -1;

        /// <summary>
        ///     A count of iterated pages thus far.
        /// </summary>
        private int _iteratedPages;

        /// <summary>
        ///     Total number of items to be fetched.
        /// </summary>
        private int _limit;

        /// <summary>
        ///     Total number of overflow items, less than the maximum number of items in a page.
        ///     Modulus of original page size.
        /// </summary>
        private int _overflowItemsCount;

        /// <summary>
        ///     Total number of pages required to iterate page collections excluding overflow items.
        /// </summary>
        private int _requiredPages;

        /// <summary>
        ///     Total number of fetched items.
        /// </summary>
        internal int TotalFetchedItems;

        /// <summary>Wait for .NET debugger to attach</summary>
        [Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [Category(ParameterCategory.Runtime)]
        public SwitchParameter Break { get; set; }

        protected abstract bool IsSingle { get; }

        /// <summary>Sets the page size of results.</summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Sets the page size of results.")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Sets the page size of results.")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Sets the page size of results.")]
        public int PageSize { get; set; }

        /// <summary>List All pages</summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "List all pages.")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "List all pages.")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "List all pages.")]
        public SwitchParameter All { get; set; }

        /// <summary>Specifies a count of the total number of items in a collection. </summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false,
            HelpMessage =
                "Specifies a count of the total number of items in a collection. By default, this variable will be set in the global scope.")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false,
            HelpMessage =
                "Specifies a count of the total number of items in a collection. By default, this variable will be set in the global scope.")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false,
            HelpMessage =
                "Specifies a count of the total number of items in a collection. By default, this variable will be set in the global scope.")]
        [Alias("CV")]
        public string CountVariable { get; set; }

        /// <summary>Expand related entities</summary>
        [Parameter(ParameterSetName = IdParameterSet, Mandatory = false, HelpMessage = "Expand related entities")]
        [Parameter(ParameterSetName = InputObjectParameterSet, Mandatory = false, HelpMessage = "Expand related entities")]
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Expand related entities")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Expand related entities")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Expand related entities")]
        [AllowEmptyCollection]
        [Alias("Expand")]
        public string[] ExpandProperty { get; set; }

        /// <summary>Select properties to be returned</summary>
        [Parameter(ParameterSetName = IdParameterSet, Mandatory = false, HelpMessage = "Select properties to be returned")]
        [Parameter(ParameterSetName = InputObjectParameterSet, Mandatory = false, HelpMessage = "Select properties to be returned")]
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Select properties to be returned")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Select properties to be returned")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Select properties to be returned")]
        [AllowEmptyCollection]
        [Alias("Select")]
        public string[] Property { get; set; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [Parameter(Mandatory = false, DontShow = true,
            HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [ValidateNotNull]
        [Category(ParameterCategory.Runtime)]
        public SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [Parameter(Mandatory = false, DontShow = true,
            HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [ValidateNotNull]
        [Category(ParameterCategory.Runtime)]
        public SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public InvocationInfo InvocationInformation
        {
            get => InvocationInfo = InvocationInfo ?? MyInvocation;
            set => InvocationInfo = value;
        }

        /// <summary>
        ///     The instance of the <see cref="HttpPipeline" /> that the remote call will use.
        /// </summary>
        protected HttpPipeline Pipeline { get; set; }

        /// <summary>The URI for the proxy server to use</summary>
        [Parameter(ParameterSetName = ProxyParameterSet, Mandatory = true, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [Category(ParameterCategory.Runtime)]
        public Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [Parameter(ParameterSetName = ProxyParameterSet, Mandatory = false, DontShow = true,
            HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [ValidateNotNull]
        [Category(ParameterCategory.Runtime)]
        public PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [Parameter(ParameterSetName = ProxyParameterSet, Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [Category(ParameterCategory.Runtime)]
        public SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>
        ///     Get a formatted url with any ids embedded but without query parameters
        /// </summary>
        protected abstract string Url { get; }

        /// <summary>Include count of items</summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Include count of items")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Include count of items")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Include count of items")]
        protected SwitchParameter Count
        {
            get => _count;
            set => _count = value;
        }

        /// <summary>Filter items by property values</summary>
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Filter items by property values")]
        [Info(
            Required = false,
            ReadOnly = false,
            Description = @"Filter items by property values",
            SerializedName = @"$filter",
            PossibleTypes = new[] {typeof(string)})]
        [Category(ParameterCategory.Query)]
        public string Filter { get; set; }

        /// <summary>Identity Parameter</summary>
        [Parameter(ParameterSetName = InputObjectParameterSet, Mandatory = true, HelpMessage = "Identity Parameter", ValueFromPipeline = true)]
        [Category(ParameterCategory.Path)]
        public virtual TModel InputObject { get; set; }

        /// <summary>Search items by search phrases</summary>
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Search items by search phrases")]
        public string Search { get; set; }

        /// <summary>Skip the first n items</summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Skip the first n items")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Skip the first n items")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Skip the first n items")]
        public int Skip { get; set; }

        /// <summary>Order items by property values</summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Order items by property values")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Order items by property values")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Order items by property values")]
        [AllowEmptyCollection]
        [Alias("OrderBy")]
        public string[] Sort { get; set; }

        /// <summary>Show only the first n items</summary>
        [Parameter(ParameterSetName = ListParameterSet, Mandatory = false, HelpMessage = "Show only the first n items")]
        [Parameter(ParameterSetName = FilterParameterSet, Mandatory = false, HelpMessage = "Show only the first n items")]
        [Parameter(ParameterSetName = SearchParameterSet, Mandatory = false, HelpMessage = "Show only the first n items")]
        [Alias("Limit")]
        public int Top
        {
            get => _top;
            set => _top = value;
        }

        /// <summary>
        ///     <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        Action IEventListener.Cancel => CancellationTokenSource.Cancel;

        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        CancellationToken IEventListener.Token => CancellationTokenSource.Token;

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        ///     A <see cref="Task" /> that will be complete when handling of the message is completed.
        /// </returns>
        async Task IEventListener.Signal(string id, CancellationToken token, Func<EventData> messageData)
        {
            using (NoSynchronizationContext)
            {
                if (token.IsCancellationRequested) return;

                switch (id)
                {
                    case Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{messageData().Message ?? string.Empty}");
                        return;
                    }
                    case Runtime.Events.Warning:
                    {
                        WriteWarning($"{messageData().Message ?? string.Empty}");
                        return;
                    }
                    case Runtime.Events.Information:
                    {
                        var data = messageData();
                        WriteInformation(data, new[] {data.Message});
                        return;
                    }
                    case Runtime.Events.Debug:
                    {
                        WriteDebug($"{messageData().Message ?? string.Empty}");
                        return;
                    }
                    case Runtime.Events.Error:
                    {
                        WriteError(new ErrorRecord(new Exception(messageData().Message), string.Empty,
                            ErrorCategory.NotSpecified, null));
                        return;
                    }
                }

                await Module.Instance.Signal(id, token, messageData,
                    (i, t, m) => ((IEventListener) this).Signal(i, t, () => EventDataConverter.ConvertFrom(m())),
                    InvocationInformation, ParameterSetName, null);
                if (token.IsCancellationRequested) return;
                WriteDebug($"{id}: {messageData().Message ?? string.Empty}");
            }
        }

        /// <summary>
        ///     Initializes paging values.
        /// </summary>
        /// <param name="invocationInfo">A reference to <see cref="System.Management.Automation.InvocationInfo" /> object.</param>
        /// <param name="top">A reference to top parameter.</param>
        public void InitializeCmdlet(ref InvocationInfo invocationInfo, ref int top, ref SwitchParameter count)
        {
            if (invocationInfo.BoundParameters.ContainsKey("PageSize") &&
                (PageSize > MaxPageSize || PageSize == default))
                ThrowTerminatingError(
                    new ErrorRecord(
                        new ArgumentException(
                            $"Invalid page size specified `{PageSize}`. {nameof(PageSize)} must be between 1 and {MaxPageSize} inclusive."),
                        Guid.NewGuid().ToString(),
                        ErrorCategory.InvalidArgument,
                        null));

            // Move `-Top` parameter to `limit`.
            if (invocationInfo.BoundParameters.ContainsKey("Top")) _limit = top;

            var currentPageSize = invocationInfo.BoundParameters.ContainsKey("PageSize") ? PageSize : DefaultPageSize;
            if (invocationInfo.BoundParameters.ContainsKey("Top") && _limit < currentPageSize) currentPageSize = _limit;

            if (invocationInfo.BoundParameters.ContainsKey("PageSize") ||
                invocationInfo.BoundParameters.ContainsKey("Top") || invocationInfo.BoundParameters.ContainsKey("All"))
            {
                // Explicitly set `-Top` parameter to currentPageSize in order for the generated cmdlets to construct a URL with a `$top` query parameter.
                invocationInfo.BoundParameters["Top"] = currentPageSize;
                top = currentPageSize;
            }

            if (_limit != default)
            {
                _requiredPages = _limit / currentPageSize;
                _overflowItemsCount = _limit % currentPageSize;
            }

            if (!invocationInfo.BoundParameters.ContainsKey("Count") &&
                invocationInfo.BoundParameters.ContainsKey("CountVariable"))
            {
                // Set Count to true when CountVariable is set.
                invocationInfo.BoundParameters["Count"] = true;
                count = true;
            }
        }

        /// <summary>
        ///     Determines whether the cmdlet should follow the OData next link URL.
        ///     Iteration will only occur when limit/top is not set, or if there a more items to fetch.
        /// </summary>
        /// <param name="boundParameters">The bound parameters of the cmdlet.</param>
        /// <param name="itemsCount">Current page items count.</param>
        /// <returns>True if it can iterate pages; otherwise False.</returns>
        public bool ShouldIteratePages(Dictionary<string, object> boundParameters, int itemsCount)
        {
            _iteratedPages++;
            TotalFetchedItems += itemsCount;

            return boundParameters.ContainsKey("All") && _limit == default || TotalFetchedItems < _limit;
        }

        protected void OnBeforeWriteObject(Dictionary<string, object> boundParameters,
            IDictionary<string, object> additionalProperties)
        {
            // Get odata.count from the response.
            if (boundParameters.ContainsKey("CountVariable") &&
                additionalProperties != null &&
                additionalProperties.TryGetValue("@odata.count", out var odataCount))
            {
                // Save the Count back to the PS environment in a global variable.
                // We need to store count in a global variable since these cmdlets are exported as functions.
                // i.e. Functions can't modify parent scope.
                var psVi = SessionState.PSVariable;
                psVi.Set(new PSVariable(CountVariable.Contains(":") ? CountVariable : $"global:{CountVariable}",
                    odataCount));
            }
        }

        /// <summary>
        ///     Gets an OData next link for the overflow items.
        /// </summary>
        /// <param name="requestUri">The OData next link returned by the service.</param>
        /// <returns>An OData next link URI for the overflow items.</returns>
        public Uri GetOverflowItemsNextLinkUri(Uri requestUri)
        {
            var nextLinkUri = new UriBuilder(requestUri);
            if (_requiredPages == _iteratedPages && _overflowItemsCount > 0)
            {
                if (nextLinkUri.Query.Contains("$top"))
                {
                    var queryString = HttpUtility.ParseQueryString(nextLinkUri.Query);
                    queryString["$top"] = Uri.EscapeDataString(_overflowItemsCount.ToString());
                    nextLinkUri.Query = queryString.ToString();
                }
                else
                {
                    nextLinkUri.Query += "$top=" + Uri.EscapeDataString(_overflowItemsCount.ToString());
                }
            }

            return nextLinkUri.Uri;
        }

        /// <summary>
        ///     Adds quotation mark around $search values if none exists.
        ///     This is needed to support KQL e.g. "prop:value".
        /// </summary>
        /// <param name="boundParameters">The bound parameters of the calling cmdlet.</param>
        /// <param name="search">The $search value.</param>
        /// <returns>A formated search value.</returns>
        protected string FormatSearchValue(Dictionary<string, object> boundParameters, string search)
        {
            if (!boundParameters.ContainsKey("Search"))
                return null;
            if (!string.IsNullOrWhiteSpace(search) && !search.StartsWith("\"")) search = $"\"{search}\"";

            return search;
        }

        /// <summary>
        ///     (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            if (InvocationInformation?.BoundParameters != null)
                InitializeCmdlet(ref InvocationInfo, ref _top, ref _count);
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break) AttachDebugger.Break();
            this.Signal(Runtime.Events.CmdletBeginProcessing).Wait();
            if (((IEventListener) this).Token.IsCancellationRequested) return;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {
            this.Signal(Runtime.Events.CmdletEndProcessing).Wait();
            if (((IEventListener) this).Token.IsCancellationRequested) return;
        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            this.Signal(Runtime.Events.CmdletProcessRecordStart).Wait();
            if (((IEventListener) this).Token.IsCancellationRequested) return;
            try
            {
                // work
                using (var asyncCommandRuntime = new AsyncCommandRuntime(this, ((IEventListener) this).Token))
                {
                    asyncCommandRuntime.Wait(ProcessRecordAsync(), ((IEventListener) this).Token);
                }
            }
            catch (AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach (var innerException in aggregateException.Flatten().InnerExceptions)
                {
                    this.Signal(Runtime.Events.CmdletException,
                            $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}")
                        .Wait();
                    if (((IEventListener) this).Token.IsCancellationRequested) return;
                    // Write exception out to error channel.
                    WriteError(new ErrorRecord(innerException, string.Empty, ErrorCategory.NotSpecified, null));
                }
            }
            catch (Exception exception) when (exception as PipelineStoppedException == null ||
                                              (exception as PipelineStoppedException).InnerException != null)
            {
                this.Signal(Runtime.Events.CmdletException,
                    $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait();
                if (((IEventListener) this).Token.IsCancellationRequested) return;
                // Write exception out to error channel.
                WriteError(new ErrorRecord(exception, string.Empty, ErrorCategory.NotSpecified, null));
            }
            finally
            {
                this.Signal(Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }


        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        ///     A <see cref="Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async Task ProcessRecordAsync()
        {
            using (NoSynchronizationContext)
            {
                await this.Signal(Runtime.Events.CmdletProcessRecordAsyncStart);
                if (((IEventListener) this).Token.IsCancellationRequested) return;
                await this.Signal(Runtime.Events.CmdletGetPipeline);
                if (((IEventListener) this).Token.IsCancellationRequested) return;
                Pipeline = Module.Instance.CreatePipeline(InvocationInformation, ParameterSetName);
                if (null != HttpPipelinePrepend)
                    Pipeline.Prepend((CommandRuntime as IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ??
                                     HttpPipelinePrepend);
                if (null != HttpPipelineAppend)
                    Pipeline.Append((CommandRuntime as IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ??
                                    HttpPipelineAppend);
                // get the client instance
                try
                {
                    await this.Signal(Runtime.Events.CmdletBeforeAPICall);
                    if (((IEventListener) this).Token.IsCancellationRequested) return;
                    if (IsSingle)
                        await Module.Instance.GraphClient.Get<TModel>(Url,
                            Property,
                            ExpandProperty,
                            OnOk, OnDefault, this, Pipeline);
                    else
                        await Module.Instance.GraphClient.List<TModel>(Url, Top, Skip,
                            FormatSearchValue(InvocationInfo.BoundParameters, Search), Filter, Count, Sort, Property,
                            ExpandProperty, OnOk, OnDefault, this, Pipeline);

                    await this.Signal(Runtime.Events.CmdletAfterAPICall);
                    if (((IEventListener) this).Token.IsCancellationRequested) return;
                }
                catch (UndeclaredResponseException urexception)
                {
                    WriteError(new ErrorRecord(urexception, urexception.StatusCode.ToString(),
                        ErrorCategory.InvalidOperation,
                        new
                        {
                            Property =
                                InvocationInformation.BoundParameters.ContainsKey("Property")
                                    ? Property
                                    : null /* arrayOf */,
                            ExpandProperty = InvocationInformation.BoundParameters.ContainsKey("ExpandProperty")
                                ? ExpandProperty
                                : null /* arrayOf */
                        })
                    {
                        ErrorDetails = new ErrorDetails(urexception.Message) {RecommendedAction = urexception.Action}
                    });
                }
                finally
                {
                    await this.Signal(Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((IEventListener) this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        ///     a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">
        ///     the body result as a <see cref="Models.IOdataError" /> from the remote
        ///     call
        /// </param>
        /// <returns>
        ///     A <see cref="Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected virtual async Task OnDefault(HttpResponseMessage responseMessage, Task<OdataError> response)
        {
            using (NoSynchronizationContext)
            {
                // Error Response : default
                // Unrecognized Response. Create an error record based on what we have.
                var ex = new RestException<OdataError>(responseMessage, await response);
                WriteError(new ErrorRecord(ex,
                    ex.Code,
                    ErrorCategory.InvalidOperation,
                    new
                    {
                        Property =
                            InvocationInformation.BoundParameters.ContainsKey("Property")
                                ? Property
                                : null /* arrayOf */,
                        ExpandProperty = InvocationInformation.BoundParameters.ContainsKey("ExpandProperty")
                            ? ExpandProperty
                            : null /* arrayOf */
                    })
                {
                    ErrorDetails = new ErrorDetails(ex.Message) {RecommendedAction = ex.Action}
                });
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">
        ///     the body result as a <see cref="Models.IMicrosoftGraphIPSecurityProfile" /> from the remote call
        /// </param>
        /// <returns>
        ///     A <see cref="Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected virtual async Task OnOk(HttpResponseMessage responseMessage, Task<TModel> response)
        {
            using (NoSynchronizationContext)
            {
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Graph.PowerShell.Models.IMicrosoftGraphIPSecurityProfile
                WriteObject(await response);
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">
        ///     the body result as a <see cref="PowerShell.Models.ICollectionOfSecurityAction" /> from the remote call
        /// </param>
        /// <returns>
        ///     A <see cref="System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async Task OnOk(HttpResponseMessage responseMessage, Task<ODataCollection<TModel>> response)
        {
            using (NoSynchronizationContext)
            {
                // onOk - response for 200 / application/json
                // response should be returning an array of some kind. +Pageable
                // pageable / value / @odata.nextLink
                var result = await response;

                OnBeforeWriteObject(InvocationInformation.BoundParameters, result?.AdditionalProperties);
                WriteObject(result.Value, true);
                if (result.OdataNextLink != null &&
                    ShouldIteratePages(InvocationInformation.BoundParameters, result.Value.Length))

                    if (responseMessage.RequestMessage is HttpRequestMessage requestMessage)
                    {
                        requestMessage = requestMessage.Clone(new Uri(result.OdataNextLink), Method.Get);
                        await this.Signal(Runtime.Events.FollowingNextLink);
                        if (((IEventListener) this).Token.IsCancellationRequested) return;
                        await Module.Instance.GraphClient.ListCall<TModel>(requestMessage, OnOk, OnDefault, this, Pipeline);
                    }
            }
        }
    }
}